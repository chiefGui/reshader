{"version":3,"file":"reshader.mjs","sources":["../src/utils/format/index.ts","../src/exceptionMessages.ts","../src/features/createShades/index.ts","../src/utils/isValidHexColor/index.ts","../src/features/createPalette/index.ts"],"sourcesContent":["export function format(content: string, tokenValue: string): string {\n  return content.replace(/%s/, tokenValue)\n}\n","export const INVALID_COLOR_STRING = `\nYou are passing an invalid or malformed color string (%s).\nTo learn more about our algorithm for hexadecimal color strings,\nplease refer to https://stackoverflow.com/a/9682781.\n`\n\nexport const INVALID_CREATE_SHADES_OPTION = `\nYou passed some invalid options when generating shades (%s).\nPlease refer to https://github.com/chiefGui/reshader to know more\nabout the available, valid options.\n`\n","import Color from \"color\"\n\nimport { isValidHexColor, format } from \"src/utils\"\nimport {\n  INVALID_COLOR_STRING,\n  INVALID_CREATE_SHADES_OPTION,\n} from \"src/exceptionMessages\"\n\nconst DEFAULT_CONTRAST_RATIO = 0.3\n\n/**\n * `createShades` returns the shades from `color`\n *\n * @param color the color the shades will be created from\n * @param options.contrastRatio (default: 0.3) from 0.1 to 1, how strong the contrast between shades will look like (0.1 is the slightest, 1 is the strongest)\n */\nexport function createShades(\n  color: string,\n  options: ICreateShadesOptions = defaultCreateShadesOptions,\n): IShades {\n  if (!isValidHexColor(color)) {\n    throw new Error(format(INVALID_COLOR_STRING, `\"${color.toString()}\"`))\n  }\n\n  const invalidOptionNames = getInvalidOptionsNames(options)\n  if (invalidOptionNames.length > 0) {\n    throw new Error(\n      format(\n        INVALID_CREATE_SHADES_OPTION,\n        `\"${invalidOptionNames.join(\", \")}\"`,\n      ),\n    )\n  }\n\n  const dark = getDarkerShadeFromColor(color, options.contrastRatio)\n  const darker = getDarkerShadeFromColor(dark, options.contrastRatio)\n  const darkest = getDarkerShadeFromColor(darker, options.contrastRatio)\n\n  const light = getLighterShadeFromColor(color, options.contrastRatio)\n  const lighter = getLighterShadeFromColor(light, options.contrastRatio)\n  const lightest = getLighterShadeFromColor(lighter, options.contrastRatio)\n\n  return {\n    darkest,\n    darker,\n    dark,\n\n    neutral: color,\n\n    light,\n    lighter,\n    lightest,\n  }\n}\n\nconst defaultCreateShadesOptions: ICreateShadesOptions = {\n  contrastRatio: DEFAULT_CONTRAST_RATIO,\n}\n\nfunction getLighterShadeFromColor(\n  color: string,\n  contrastRatio: number = DEFAULT_CONTRAST_RATIO,\n): string {\n  return Color(color)\n    .lighten(contrastRatio)\n    .hex()\n}\n\nfunction getDarkerShadeFromColor(\n  color: string,\n  contrastRatio: number = DEFAULT_CONTRAST_RATIO,\n): string {\n  return Color(color)\n    .darken(contrastRatio)\n    .hex()\n}\n\nfunction getInvalidOptionsNames(\n  createShadesOptions: ICreateShadesOptions,\n): string[] {\n  const dirtyOptionsNames = Object.keys(createShadesOptions)\n  const validOptionsNames = Object.keys(defaultCreateShadesOptions)\n\n  if (dirtyOptionsNames.length === 0) {\n    return []\n  }\n\n  const invalidOptionsNames: string[] = dirtyOptionsNames.filter(\n    dirtyOptionName => {\n      if (!validOptionsNames.includes(dirtyOptionName)) {\n        return true\n      }\n\n      return false\n    },\n  )\n\n  return invalidOptionsNames\n}\n\nexport interface ICreateShadesOptions {\n  /**\n   * `contrastRatio`\n   * (default: 0.3) from 0.1 to 1, how strong the contrast between shades will look like (0.1 is the slightest, 1 is the strongest)\n   */\n  contrastRatio?: number\n}\n\nexport interface IShades {\n  darkest: string\n  darker: string\n  dark: string\n  neutral: string\n  light: string\n  lighter: string\n  lightest: string\n}\n","/**\n * isValidHexColor checks whether a given color string matches\n * a hexadecimal string.\n *\n * @param maybeHexColor the string to check\n */\nexport function isValidHexColor(maybeHexColor: string): boolean {\n  return /^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(maybeHexColor)\n}\n","import { createShades, IShades, ICreateShadesOptions } from \"../createShades\"\n\n/**\n * `createPalette` returns shades for every color present on its first argument.\n *\n * @param {string | TColorsShape} colors - The colors you want to generate shades from.\n */\nexport function createPalette<TColors extends TColorsShape>(\n  colors: TColors,\n): TPalette<TColors> {\n  const colorNames = Object.keys(colors) as (keyof TColors)[]\n\n  return colorNames.reduce(\n    (previousColor, currentColor) => {\n      /**\n       * Let's normalize the color input\n       */\n      const colorShape = getColorShape(colors[currentColor])\n\n      previousColor[currentColor] = createShades(\n        colorShape.hex,\n        colorShape.options,\n      )\n\n      return previousColor\n    },\n    {} as TPalette<TColors>,\n  )\n}\n\nfunction getColorShape(color: string | IColorShape): IColorShape {\n  if (typeof color === \"string\") {\n    return {\n      hex: color,\n      options: {},\n    }\n  }\n\n  return color\n}\n\ntype TColorsShape = { [colorName: string]: string | IColorShape }\n\ninterface IColorShape {\n  /**\n   * A valid hexadecimal string that represents a given color.\n   * Passing an invalid value here will throw an exception.\n   */\n  hex: string\n\n  /**\n   * The options used to generate the shades for this given color.\n   * Same as the options of `createShades`, as seen in `ICreateShadesOptions`.\n   */\n  options?: ICreateShadesOptions\n}\n\ntype TPalette<TColors extends TColorsShape> = {\n  [colorName in keyof TColors]: IShades\n}\n"],"names":["format","content","tokenValue","replace","const","INVALID_COLOR_STRING","INVALID_CREATE_SHADES_OPTION","DEFAULT_CONTRAST_RATIO","createShades","color","options","defaultCreateShadesOptions","test","Error","toString","dirtyOptionsNames","validOptionsNames","invalidOptionNames","Object","keys","length","filter","dirtyOptionName","includes","join","dark","getDarkerShadeFromColor","contrastRatio","darker","darkest","light","getLighterShadeFromColor","lighter","neutral","Color","lighten","hex","darken","createPalette","colors","reduce","previousColor","currentColor","colorShape"],"mappings":"8BAAgBA,EAAOC,EAAiBC,UAC/BD,EAAQE,QAAQ,KAAMD,GCDxBE,IAAMC,2LAMAC,6KCEPC,EAAyB,YAQfC,EACdC,EACAC,qBAAgCC,ICXzB,gCAAgCC,KDalBH,SACb,IAAII,MAAMb,EAAOK,MAA0BI,EAAMK,qBA2DnDC,EACAC,EAzDAC,GAwDAF,EAAoBG,OAAOC,KAxDiBT,GAyD5CM,EAAoBE,OAAOC,KAAKR,GAEL,IAA7BI,EAAkBK,OACb,GAG6BL,EAAkBM,gBACtDC,UACON,EAAkBO,SAASD,SAhEhCL,EAAmBG,OAAS,QACxB,IAAIP,MACRb,EACEM,MACIW,EAAmBO,KAAK,gBAK5BC,EAAOC,EAAwBjB,EAAOC,EAAQiB,eAC9CC,EAASF,EAAwBD,EAAMf,EAAQiB,eAC/CE,EAAUH,EAAwBE,EAAQlB,EAAQiB,eAElDG,EAAQC,EAAyBtB,EAAOC,EAAQiB,eAChDK,EAAUD,EAAyBD,EAAOpB,EAAQiB,qBAGjD,SACLE,SACAD,OACAH,EAEAQ,QAASxB,QAETqB,UACAE,WAVeD,EAAyBC,EAAStB,EAAQiB,gBAe7DvB,IAAMO,EAAmD,CACvDgB,cAAepB,GAGjB,SAASwB,EACPtB,EACAkB,yBAAwBpB,GAEjB2B,EAAMzB,GACV0B,QAAQR,GACRS,MAGL,SAASV,EACPjB,EACAkB,yBAAwBpB,GAEjB2B,EAAMzB,GACV4B,OAAOV,GACPS,eEnEWE,EACdC,UAEmBrB,OAAOC,KAAKoB,GAEbC,gBACfC,EAAeC,OAiBGjC,EAbXkC,EAcW,iBADAlC,EAbgB8B,EAAOG,IAenC,CACLN,IAAK3B,EACLC,QAAS,IAIND,SAnBHgC,EAAcC,GAAgBlC,EAC5BmC,EAAWP,IACXO,EAAWjC,SAGN+B,GAET"}