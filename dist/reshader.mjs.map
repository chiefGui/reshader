{"version":3,"file":"reshader.mjs","sources":["../src/utils/format/index.ts","../src/features/createSwatch/index.ts","../src/features/createSwatch/hydrateSwatchName/index.ts","../src/utils/isValidHexColor/index.ts","../src/features/createShades/index.ts","../src/features/createPalette/index.ts","../src/parsers/parseSwatchToJSON/index.ts","../src/parsers/parseSwatchToJS/index.ts","../src/parsers/parseSwatchToCSS/index.ts","../src/parsers/parseSwatchToSCSS/index.ts"],"sourcesContent":["export function format(content: string, tokenValue: string): string {\n  return content.replace(/%s/, tokenValue)\n}\n","import ntc from \"ntcjs\"\n\nimport { IShades } from \"../createShades\"\nimport { hydrateSwatchName } from \"./hydrateSwatchName\"\nimport { format } from \"src/utils/format\"\n\nexport function createSwatch({\n  formalName,\n  shades,\n  contrastRatio,\n}: TCreateSwatch): ISwatch {\n  if (!shades) {\n    throw new Error(EXCEPTION__UNDEFINED_SHADES)\n  }\n\n  if (!shades.neutral) {\n    throw new Error(\n      format(EXCEPTION__NO_NEUTRAL, JSON.stringify(shades, null, 2)),\n    )\n  }\n\n  const actualFormalName = formalName || ntc.name(shades.neutral)[1]\n  const hydratedName = hydrateSwatchName(actualFormalName)\n\n  return {\n    formalName: actualFormalName,\n    hydratedName,\n    contrastRatio: contrastRatio || 0.2,\n    shades,\n  }\n}\n\nexport interface ISwatch {\n  formalName: string\n  hydratedName: string\n  shades: IShades\n  contrastRatio: number\n}\n\ntype TCreateSwatch = Pick<ISwatch, \"shades\"> & {\n  formalName?: string\n  contrastRatio?: number\n}\n\nexport const EXCEPTION__UNDEFINED_SHADES = `\"createSwatch\" requires at least the argument \"shades\"`\nexport const EXCEPTION__NO_NEUTRAL = `You are trying to run \"createSwatch\" without passing the \"neutral\" shade\nthrough the \"shades\" property. What we actually got is this: (\"%s\").\nPlease, make sure the shade \"neutral\" is present and is a valid hex code.`\n","export function hydrateSwatchName(dirtySwatchName: string): string {\n  const trimmed = dirtySwatchName.trim()\n  const camelized = camelize(trimmed)\n  const validCharactersOnly = removeWeirdCharacters(camelized)\n\n  return validCharactersOnly\n}\n\nfunction camelize(str: string): string {\n  return str\n    .replace(/(?:^\\w|[A-Z]|\\b\\w)/g, function(word, index) {\n      return index == 0 ? word.toLowerCase() : word.toUpperCase()\n    })\n    .replace(/\\s+/g, \"\")\n}\n\nfunction removeWeirdCharacters(str: string): string {\n  return str.replace(/[^a-zA-Z0-9]/g, \"\").replace(/['\"]+/g, \"\")\n}\n","/**\n * isValidHexColor checks whether a given color string matches\n * a hexadecimal string.\n *\n * @param maybeHexColor the string to check\n */\nexport function isValidHexColor(maybeHexColor: string): boolean {\n  return /^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(maybeHexColor)\n}\n","import Color from \"color\"\n\nimport { isValidHexColor, format } from \"src/utils\"\n\nconst DEFAULT_CONTRAST_RATIO = 0.2\n\n/**\n * `createShades` returns the shades from `color`\n *\n * @param color the color the shades will be created from\n * @param options.contrastRatio (default: 0.1) from 0.1 to 1, how strong the contrast between shades will look like (0.1 is the slightest, 1 is the strongest)\n */\nexport function createShades(\n  color: string,\n  options: ICreateShadesOptions = defaultCreateShadesOptions,\n): IShades {\n  if (!isValidHexColor(color)) {\n    throw new Error(\n      format(EXCEPTION__INVALID_COLOR_STRING, `\"${color.toString()}\"`),\n    )\n  }\n\n  const invalidOptionNames = getInvalidOptionsNames(options)\n  if (invalidOptionNames.length > 0) {\n    throw new Error(\n      format(\n        EXCEPTION__INVALID_CREATE_SHADES_OPTIONS,\n        `\"${invalidOptionNames.join(\", \")}\"`,\n      ),\n    )\n  }\n\n  const dark = getDarkerShadeFromColor(color, options.contrastRatio)\n  const darker = getDarkerShadeFromColor(dark, options.contrastRatio)\n  const darkest = getDarkerShadeFromColor(darker, options.contrastRatio)\n\n  const light = getLighterShadeFromColor(color, options.contrastRatio)\n  const lighter = getLighterShadeFromColor(light, options.contrastRatio)\n  const lightest = getLighterShadeFromColor(lighter, options.contrastRatio)\n\n  return {\n    darkest,\n    darker,\n    dark,\n\n    neutral: color.toUpperCase(),\n\n    light,\n    lighter,\n    lightest,\n  }\n}\n\nconst defaultCreateShadesOptions: ICreateShadesOptions = {\n  contrastRatio: DEFAULT_CONTRAST_RATIO,\n}\n\nfunction getLighterShadeFromColor(\n  color: string,\n  contrastRatio: number = DEFAULT_CONTRAST_RATIO,\n): string {\n  return Color(color)\n    .lighten(contrastRatio)\n    .hex()\n}\n\nfunction getDarkerShadeFromColor(\n  color: string,\n  contrastRatio: number = DEFAULT_CONTRAST_RATIO,\n): string {\n  return Color(color)\n    .darken(contrastRatio)\n    .hex()\n}\n\nfunction getInvalidOptionsNames(\n  createShadesOptions: ICreateShadesOptions,\n): string[] {\n  const dirtyOptionsNames = Object.keys(createShadesOptions)\n  const validOptionsNames = Object.keys(defaultCreateShadesOptions)\n\n  if (dirtyOptionsNames.length === 0) {\n    return []\n  }\n\n  const invalidOptionsNames: string[] = dirtyOptionsNames.filter(\n    dirtyOptionName => {\n      if (!validOptionsNames.includes(dirtyOptionName)) {\n        return true\n      }\n\n      return false\n    },\n  )\n\n  return invalidOptionsNames\n}\n\nexport const EXCEPTION__INVALID_COLOR_STRING = `You are passing an invalid or malformed color string (%s).\nTo learn more about our algorithm for hexadecimal color strings,\nplease refer to https://stackoverflow.com/a/9682781.\n`\n\nexport const EXCEPTION__INVALID_CREATE_SHADES_OPTIONS = `You passed some invalid options when generating shades (%s).\nPlease refer to https://github.com/chiefGui/reshader to know more\nabout the available, valid options.\n`\n\nexport interface ICreateShadesOptions {\n  /**\n   * `contrastRatio`\n   * (default: 0.3) from 0.1 to 1, how strong the contrast between shades will look like (0.1 is the slightest, 1 is the strongest)\n   */\n  contrastRatio?: number\n}\n\nexport interface IShades {\n  darkest: string\n  darker: string\n  dark: string\n  neutral: string\n  light: string\n  lighter: string\n  lightest: string\n}\n","import { createShades, IShades, ICreateShadesOptions } from \"../createShades\"\n\n/**\n * `createPalette` returns shades for every color present on its first argument.\n *\n * @param {string | TColorsShape} colors - The colors you want to generate shades from.\n */\nexport function createPalette<TColors extends TColorsShape>(\n  colors: TColors,\n): TPalette<TColors> {\n  const colorNames = Object.keys(colors) as (keyof TColors)[]\n\n  return colorNames.reduce(\n    (previousColor, currentColor) => {\n      /**\n       * Let's normalize the color input\n       */\n      const colorShape = getColorShape(colors[currentColor])\n\n      previousColor[currentColor] = createShades(\n        colorShape.hex,\n        colorShape.options,\n      )\n\n      return previousColor\n    },\n    {} as TPalette<TColors>,\n  )\n}\n\nfunction getColorShape(color: string | IColorShape): IColorShape {\n  if (typeof color === \"string\") {\n    return {\n      hex: color,\n      options: {},\n    }\n  }\n\n  return color\n}\n\ntype TColorsShape = { [colorName: string]: string | IColorShape }\n\ninterface IColorShape {\n  /**\n   * A valid hexadecimal string that represents a given color.\n   * Passing an invalid value here will throw an exception.\n   */\n  hex: string\n\n  /**\n   * The options used to generate the shades for this given color.\n   * Same as the options of `createShades`, as seen in `ICreateShadesOptions`.\n   */\n  options?: ICreateShadesOptions\n}\n\nexport type TPalette<TColors extends TColorsShape> = {\n  [colorName in keyof TColors]: IShades\n}\n","import { ISwatch } from \"src/features/createSwatch\"\n\nexport function parseSwatchToJSON(\n  swatch: ISwatch,\n  options: IParseSwatchToJSONOptions = {\n    numberOfSpaces: 0,\n  },\n): string {\n  const bracketSpaces =\n    options.numberOfSpaces === 0 ? \"\" : getSpaces(options.numberOfSpaces)\n\n  const swatchNameSpaces =\n    options.numberOfSpaces === 0\n      ? \"  \"\n      : bracketSpaces + getSpaces(options.numberOfSpaces)\n\n  const shadeSpaces =\n    options.numberOfSpaces === 0\n      ? \"    \"\n      : swatchNameSpaces + getSpaces(options.numberOfSpaces)\n\n  return `${bracketSpaces}{\n${swatchNameSpaces}\"${swatch.hydratedName}\": {\n${shadeSpaces}\"darkest\": \"${swatch.shades.darkest}\",\n${shadeSpaces}\"darker\": \"${swatch.shades.darker}\",\n${shadeSpaces}\"dark\": \"${swatch.shades.dark}\",\n${shadeSpaces}\"neutral\": \"${swatch.shades.neutral}\",\n${shadeSpaces}\"light\": \"${swatch.shades.light}\",\n${shadeSpaces}\"lighter\": \"${swatch.shades.lighter}\",\n${shadeSpaces}\"lightest\": \"${swatch.shades.lightest}\"\n${swatchNameSpaces}}\n${bracketSpaces}}`\n}\n\nfunction getSpaces(numberOfSpaces: number): string {\n  return new Array(numberOfSpaces).fill(\" \").join(\"\")\n}\n\ninterface IParseSwatchToJSONOptions {\n  numberOfSpaces: number\n}\n","import { ISwatch } from \"src/features/createSwatch\"\n\nexport function parseSwatchToJS(\n  swatch: ISwatch,\n  options: IParseSwatchToJSOptions = {\n    numberOfSpaces: 0,\n  },\n): string {\n  const bracketSpaces =\n    options.numberOfSpaces === 0 ? \"\" : getSpaces(options.numberOfSpaces)\n\n  const swatchNameSpaces =\n    options.numberOfSpaces === 0\n      ? \"  \"\n      : bracketSpaces + getSpaces(options.numberOfSpaces)\n\n  const shadeSpaces =\n    options.numberOfSpaces === 0\n      ? \"    \"\n      : swatchNameSpaces + getSpaces(options.numberOfSpaces)\n\n  return `${bracketSpaces}{\n${swatchNameSpaces}${swatch.hydratedName}: {\n${shadeSpaces}darkest: \"${swatch.shades.darkest}\",\n${shadeSpaces}darker: \"${swatch.shades.darker}\",\n${shadeSpaces}dark: \"${swatch.shades.dark}\",\n${shadeSpaces}neutral: \"${swatch.shades.neutral}\",\n${shadeSpaces}light: \"${swatch.shades.light}\",\n${shadeSpaces}lighter: \"${swatch.shades.lighter}\",\n${shadeSpaces}lightest: \"${swatch.shades.lightest}\"\n${swatchNameSpaces}}\n${bracketSpaces}}`\n}\n\nfunction getSpaces(numberOfSpaces: number): string {\n  return new Array(numberOfSpaces).fill(\" \").join(\"\")\n}\n\ninterface IParseSwatchToJSOptions {\n  numberOfSpaces: number\n}\n","import { ISwatch } from \"src/features/createSwatch\"\n\nexport function parseSwatchToCSS(\n  swatch: ISwatch,\n  options: IParseSwatchToCSSOptions = {\n    numberOfSpaces: 0,\n  },\n): string {\n  const bracketSpaces =\n    options.numberOfSpaces === 0 ? \"\" : getSpaces(options.numberOfSpaces)\n\n  const swatchNameSpaces =\n    options.numberOfSpaces === 0\n      ? \"  \"\n      : bracketSpaces + getSpaces(options.numberOfSpaces)\n\n  const shadeSpaces =\n    options.numberOfSpaces === 0\n      ? \"    \"\n      : swatchNameSpaces + getSpaces(options.numberOfSpaces)\n\n  return `:root {\n  --palette-${swatch.hydratedName}--darkest: ${swatch.shades.darkest};\n  --palette-${swatch.hydratedName}--darker: ${swatch.shades.darker};\n  --palette-${swatch.hydratedName}--dark: ${swatch.shades.dark};\n  --palette-${swatch.hydratedName}--neutral: ${swatch.shades.neutral};\n  --palette-${swatch.hydratedName}--light: ${swatch.shades.light};\n  --palette-${swatch.hydratedName}--lighter: ${swatch.shades.lighter};\n  --palette-${swatch.hydratedName}--lightest: ${swatch.shades.lightest};\n}`\n}\n\nfunction getSpaces(numberOfSpaces: number): string {\n  return new Array(numberOfSpaces).fill(\" \").join(\"\")\n}\n\ninterface IParseSwatchToCSSOptions {\n  numberOfSpaces: number\n}\n","import { ISwatch } from \"src/features/createSwatch\"\n\nexport function parseSwatchToSCSS(swatch: ISwatch): string {\n  return `$palette-${swatch.hydratedName}--darkest: ${swatch.shades.darkest};\n$palette-${swatch.hydratedName}--darker: ${swatch.shades.darker};\n$palette-${swatch.hydratedName}--dark: ${swatch.shades.dark};\n$palette-${swatch.hydratedName}--neutral: ${swatch.shades.neutral};\n$palette-${swatch.hydratedName}--light: ${swatch.shades.light};\n$palette-${swatch.hydratedName}--lighter: ${swatch.shades.lighter};\n$palette-${swatch.hydratedName}--lightest: ${swatch.shades.lightest};`\n}\n"],"names":["format","content","tokenValue","replace","createSwatch","ref","shades","Error","EXCEPTION__UNDEFINED_SHADES","neutral","EXCEPTION__NO_NEUTRAL","JSON","stringify","actualFormalName","formalName","ntc","name","trim","word","index","toLowerCase","toUpperCase","contrastRatio","isValidHexColor","maybeHexColor","test","const","DEFAULT_CONTRAST_RATIO","createShades","color","options","defaultCreateShadesOptions","EXCEPTION__INVALID_COLOR_STRING","toString","dirtyOptionsNames","validOptionsNames","invalidOptionNames","Object","keys","length","filter","dirtyOptionName","includes","EXCEPTION__INVALID_CREATE_SHADES_OPTIONS","join","dark","getDarkerShadeFromColor","darker","darkest","light","getLighterShadeFromColor","lighter","lightest","Color","lighten","hex","darken","createPalette","colors","reduce","previousColor","currentColor","colorShape","parseSwatchToJSON","swatch","numberOfSpaces","bracketSpaces","getSpaces","swatchNameSpaces","shadeSpaces","Array","fill","parseSwatchToJS","parseSwatchToCSS","parseSwatchToSCSS"],"mappings":"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"}